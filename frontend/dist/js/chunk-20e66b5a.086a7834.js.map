{"version":3,"sources":["webpack:///./src/templates/Maps.vue?234e","webpack:///./node_modules/@google/markerclusterer/src/markerclusterer.js","webpack:///./src/templates/Maps.vue?9138","webpack:///./src/utils/gmaps.js","webpack:///src/templates/Maps.vue","webpack:///./src/templates/Maps.vue?8274","webpack:///./src/templates/Maps.vue?2e56","webpack:///./node_modules/core-js/modules/es.array.map.js"],"names":["MarkerClusterer","map","opt_markers","opt_options","this","extend","google","maps","OverlayView","map_","markers_","clusters_","sizes","styles_","ready_","options","gridSize_","minClusterSize_","maxZoom_","imagePath_","MARKER_CLUSTER_IMAGE_PATH_","imageExtension_","MARKER_CLUSTER_IMAGE_EXTENSION_","zoomOnClick_","undefined","averageCenter_","setupStyles_","setMap","prevZoom_","getZoom","that","event","addListener","zoom","minZoom","maxZoom","Math","min","mapTypes","getMapTypeId","max","resetViewport","redraw","length","Object","keys","addMarkers","Cluster","markerClusterer","markerClusterer_","getMap","getGridSize","getMinClusterSize","isAverageCenter","center_","bounds_","clusterIcon_","ClusterIcon","getStyles","cluster","styles","opt_padding","getMarkerClusterer","padding_","cluster_","div_","sums_","visible_","prototype","obj1","obj2","object","property","apply","onAdd","setReady_","draw","size","i","push","url","height","width","fitMapToMarkers","marker","markers","getMarkers","bounds","LatLngBounds","getPosition","fitBounds","setStyles","isZoomOnClick","getTotalMarkers","setMaxZoom","getMaxZoom","calculator_","numStyles","index","count","dv","parseInt","text","setCalculator","calculator","getCalculator","opt_nodraw","pushMarkerTo_","isAdded","repaint","addMarker","removeMarker_","indexOf","m","splice","removeMarker","removed","removeMarkers","markersCopy","slice","r","ready","createClusters_","getTotalClusters","setGridSize","setMinClusterSize","getExtendedBounds","projection","getProjection","tr","LatLng","getNorthEast","lat","lng","bl","getSouthWest","trPix","fromLatLngToDivPixel","x","y","blPix","ne","fromDivPixelToLatLng","sw","isMarkerInBounds_","contains","clearMarkers","opt_hide","remove","oldClusters","window","setTimeout","distanceBetweenPoints_","p1","p2","R","dLat","PI","dLon","a","sin","cos","c","atan2","sqrt","d","addToClosestCluster_","distance","clusterToAddTo","center","getCenter","isMarkerInClusterBounds","mapBounds","getBounds","isMarkerAlreadyAdded","l","calculateBounds_","len","updateIcon","getSize","mz","hide","sums","setCenter","setSums","show","triggerClusterClick","trigger","document","createElement","pos","getPosFromLatLng_","style","cssText","createCss","innerHTML","panes","getPanes","overlayMouseTarget","appendChild","addDomListener","latlng","width_","height_","top","left","zIndex","Marker","MAX_ZINDEX","display","onRemove","parentNode","removeChild","text_","index_","useStyle","url_","textColor_","anchor_","textSize_","backgroundPosition_","backgroundPosition","txtColor","txtSize","join","o","result","name","hasOwnProperty","module","exports","resolveInitPromise","rejectInitPromise","render","_vm","_h","$createElement","_c","_self","staticClass","attrs","_v","staticRenderFns","API_KEY","CALLBACK_NAME","initialized","initPromise","Promise","resolve","reject","init","script","async","defer","src","onerror","querySelector","component","$","$map","arrayMethodHasSpeciesSupport","arrayMethodUsesToLength","HAS_SPECIES_SUPPORT","USES_TO_LENGTH","target","proto","forced","callbackfn","arguments"],"mappings":"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","file":"js/chunk-20e66b5a.086a7834.js","sourcesContent":["import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Maps.vue?vue&type=style&index=0&id=c8d5167e&scoped=true&lang=css&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Maps.vue?vue&type=style&index=0&id=c8d5167e&scoped=true&lang=css&\"","// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3_3.js\n// ==/ClosureCompiler==\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0.3\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'imagePath': (string) The base URL where the images representing\n *                  clusters will be found. The full URL will be:\n *                  {imagePath}[1-5].{imageExtension}\n *                  Default: '../images/m'.\n *     'imageExtension': (string) The suffix for images URL representing\n *                       clusters will be found. See _imagePath_ for details.\n *                       Default: 'png'.\n *     'averageCenter': (boolean) Whether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  this.map_ = map;\n\n  /**\n   * @type {Array.<google.maps.Marker>}\n   * @private\n   */\n  this.markers_ = [];\n\n  /**\n   *  @type {Array.<Cluster>}\n   */\n  this.clusters_ = [];\n\n  this.sizes = [53, 56, 66, 78, 90];\n\n  /**\n   * @private\n   */\n  this.styles_ = [];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.ready_ = false;\n\n  var options = opt_options || {};\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.gridSize_ = options['gridSize'] || 60;\n\n  /**\n   * @private\n   */\n  this.minClusterSize_ = options['minimumClusterSize'] || 2;\n\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.maxZoom_ = options['maxZoom'] || null;\n\n  this.styles_ = options['styles'] || [];\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imagePath_ = options['imagePath'] ||\n      this.MARKER_CLUSTER_IMAGE_PATH_;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imageExtension_ = options['imageExtension'] ||\n      this.MARKER_CLUSTER_IMAGE_EXTENSION_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.zoomOnClick_ = true;\n\n  if (options['zoomOnClick'] != undefined) {\n    this.zoomOnClick_ = options['zoomOnClick'];\n  }\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.averageCenter_ = false;\n\n  if (options['averageCenter'] != undefined) {\n    this.averageCenter_ = options['averageCenter'];\n  }\n\n  this.setupStyles_();\n\n  this.setMap(map);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevZoom_ = this.map_.getZoom();\n\n  // Add the map event listeners\n  var that = this;\n  google.maps.event.addListener(this.map_, 'zoom_changed', function() {\n    // Determines map type and prevent illegal zoom levels\n    var zoom = that.map_.getZoom();\n    var minZoom = that.map_.minZoom || 0;\n    var maxZoom = Math.min(that.map_.maxZoom || 100,\n                         that.map_.mapTypes[that.map_.getMapTypeId()].maxZoom);\n    zoom = Math.min(Math.max(zoom,minZoom),maxZoom);\n\n    if (that.prevZoom_ != zoom) {\n      that.prevZoom_ = zoom;\n      that.resetViewport();\n    }\n  });\n\n  google.maps.event.addListener(this.map_, 'idle', function() {\n    that.redraw();\n  });\n\n  // Finally, add the markers\n  if (opt_markers && (opt_markers.length || Object.keys(opt_markers).length)) {\n    this.addMarkers(opt_markers, false);\n  }\n}\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ = '../images/m';\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n\n\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function(obj1, obj2) {\n  return (function(object) {\n    for (var property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }).apply(obj1, [obj2]);\n};\n\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function() {\n  this.setReady_(true);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function() {};\n\n/**\n * Sets up the styles object.\n *\n * @private\n */\nMarkerClusterer.prototype.setupStyles_ = function() {\n  if (this.styles_.length) {\n    return;\n  }\n\n  for (var i = 0, size; size = this.sizes[i]; i++) {\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function() {\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  this.map_.fitBounds(bounds);\n};\n\n\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\nMarkerClusterer.prototype.setStyles = function(styles) {\n  this.styles_ = styles;\n};\n\n\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\nMarkerClusterer.prototype.getStyles = function() {\n  return this.styles_;\n};\n\n\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\nMarkerClusterer.prototype.isZoomOnClick = function() {\n  return this.zoomOnClick_;\n};\n\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\nMarkerClusterer.prototype.isAverageCenter = function() {\n  return this.averageCenter_;\n};\n\n\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\nMarkerClusterer.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function() {\n  return this.markers_.length;\n};\n\n\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function(maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function() {\n  return this.maxZoom_;\n};\n\n\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\nMarkerClusterer.prototype.calculator_ = function(markers, numStyles) {\n  var index = 0;\n  var count = markers.length;\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index\n  };\n};\n\n\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\nMarkerClusterer.prototype.setCalculator = function(calculator) {\n  this.calculator_ = calculator;\n};\n\n\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\nMarkerClusterer.prototype.getCalculator = function() {\n  return this.calculator_;\n};\n\n\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {\n  if (markers.length) {\n    for (var i = 0, marker; marker = markers[i]; i++) {\n      this.pushMarkerTo_(marker);\n    }\n  } else if (Object.keys(markers).length) {\n    for (var marker in markers) {\n      this.pushMarkerTo_(markers[marker]);\n    }\n  }\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function(marker) {\n  marker.isAdded = false;\n  if (marker['draggable']) {\n    // If the marker is draggable add a listener so we update the clusters on\n    // the drag end.\n    var that = this;\n    google.maps.event.addListener(marker, 'dragend', function() {\n      marker.isAdded = false;\n      that.repaint();\n    });\n  }\n  this.markers_.push(marker);\n};\n\n\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\nMarkerClusterer.prototype.removeMarker_ = function(marker) {\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index == -1) {\n    // Marker is not in our list of markers.\n    return false;\n  }\n\n  marker.setMap(null);\n\n  this.markers_.splice(index, 1);\n\n  return true;\n};\n\n\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\nMarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  } else {\n   return false;\n  }\n};\n\n\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\nMarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {\n  // create a local copy of markers if required\n  // (removeMarker_ modifies the getMarkers() array in place)\n  var markersCopy = markers === this.getMarkers() ? markers.slice() : markers;\n  var removed = false;\n\n  for (var i = 0, marker; marker = markersCopy[i]; i++) {\n    var r = this.removeMarker_(marker);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  }\n};\n\n\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\nMarkerClusterer.prototype.setReady_ = function(ready) {\n  if (!this.ready_) {\n    this.ready_ = ready;\n    this.createClusters_();\n  }\n};\n\n\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\nMarkerClusterer.prototype.getTotalClusters = function() {\n  return this.clusters_.length;\n};\n\n\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nMarkerClusterer.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\nMarkerClusterer.prototype.setMap = function(map) {\n  this.map_ = map;\n};\n\n\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function() {\n  return this.gridSize_;\n};\n\n\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function(size) {\n  this.gridSize_ = size;\n};\n\n\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getMinClusterSize = function() {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setMinClusterSize = function(size) {\n  this.minClusterSize_ = size;\n};\n\n\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\nMarkerClusterer.prototype.getExtendedBounds = function(bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n\n  return bounds;\n};\n\n\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n\n/**\n * Clears all clusters and markers from the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function() {\n  this.resetViewport(true);\n\n  // Set the markers a empty array.\n  this.markers_ = [];\n};\n\n\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\nMarkerClusterer.prototype.resetViewport = function(opt_hide) {\n  // Remove all the clusters\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    cluster.remove();\n  }\n\n  // Reset the markers to not be added and to be invisible.\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n\n  this.clusters_ = [];\n};\n\n/**\n *\n */\nMarkerClusterer.prototype.repaint = function() {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_.length = 0;\n  this.resetViewport();\n  this.redraw();\n\n  // Remove the old clusters.\n  // Do it in a timeout so the other clusters have been drawn first.\n  window.setTimeout(function() {\n    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {\n      cluster.remove();\n    }\n  }, 0);\n};\n\n\n/**\n * Redraws the clusters.\n */\nMarkerClusterer.prototype.redraw = function() {\n  this.createClusters_();\n};\n\n\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n*/\nMarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {\n  if (!p1 || !p2) {\n    return 0;\n  }\n\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  var pos = marker.getPosition();\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    var center = cluster.getCenter();\n    if (center) {\n      var d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    var cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n\n/**\n * Creates the clusters.\n *\n * @private\n */\nMarkerClusterer.prototype.createClusters_ = function() {\n  if (!this.ready_) {\n    return;\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),\n      this.map_.getBounds().getNorthEast());\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      this.addToClosestCluster_(marker);\n    }\n  }\n};\n\n\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\nfunction Cluster(markerClusterer) {\n  this.markerClusterer_ = markerClusterer;\n  this.map_ = markerClusterer.getMap();\n  this.gridSize_ = markerClusterer.getGridSize();\n  this.minClusterSize_ = markerClusterer.getMinClusterSize();\n  this.averageCenter_ = markerClusterer.isAverageCenter();\n  this.center_ = null;\n  this.markers_ = [];\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),\n      markerClusterer.getGridSize());\n}\n\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\nCluster.prototype.isMarkerAlreadyAdded = function(marker) {\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) != -1;\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\nCluster.prototype.addMarker = function(marker) {\n  if (this.isMarkerAlreadyAdded(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n\n  var len = this.markers_.length;\n  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n    // Min cluster size not reached so show the marker.\n    marker.setMap(this.map_);\n  }\n\n  if (len == this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (var i = 0; i < len; i++) {\n      this.markers_[i].setMap(null);\n    }\n  }\n\n  if (len >= this.minClusterSize_) {\n    marker.setMap(null);\n  }\n\n  this.updateIcon();\n  return true;\n};\n\n\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\nCluster.prototype.getMarkerClusterer = function() {\n  return this.markerClusterer_;\n};\n\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\nCluster.prototype.getBounds = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n  return bounds;\n};\n\n\n/**\n * Removes the cluster\n */\nCluster.prototype.remove = function() {\n  this.clusterIcon_.remove();\n  this.markers_.length = 0;\n  delete this.markers_;\n};\n\n\n/**\n * Returns the number of markers in the cluster.\n *\n * @return {number} The number of markers in the cluster.\n */\nCluster.prototype.getSize = function() {\n  return this.markers_.length;\n};\n\n\n/**\n * Returns a list of the markers in the cluster.\n *\n * @return {Array.<google.maps.Marker>} The markers in the cluster.\n */\nCluster.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\nCluster.prototype.getCenter = function() {\n  return this.center_;\n};\n\n\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\nCluster.prototype.calculateBounds_ = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\nCluster.prototype.isMarkerInClusterBounds = function(marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nCluster.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Updates the cluster icon\n */\nCluster.prototype.updateIcon = function() {\n  var zoom = this.map_.getZoom();\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz && zoom > mz) {\n    // The zoom is greater than our max zoom so show all the markers in cluster.\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\n      marker.setMap(this.map_);\n    }\n    return;\n  }\n\n  if (this.markers_.length < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.setSums(sums);\n  this.clusterIcon_.show();\n};\n\n\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\nfunction ClusterIcon(cluster, styles, opt_padding) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n  this.styles_ = styles;\n  this.padding_ = opt_padding || 0;\n  this.cluster_ = cluster;\n  this.center_ = null;\n  this.map_ = cluster.getMap();\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n\n  this.setMap(this.map_);\n}\n\n\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n */\nClusterIcon.prototype.triggerClusterClick = function() {\n  var markerClusterer = this.cluster_.getMarkerClusterer();\n\n  // Trigger the clusterclick event.\n  google.maps.event.trigger(markerClusterer.map_, 'clusterclick', this.cluster_);\n\n  if (markerClusterer.isZoomOnClick()) {\n    // Zoom into the cluster.\n    this.map_.fitBounds(this.cluster_.getBounds());\n  }\n};\n\n\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\nClusterIcon.prototype.onAdd = function() {\n  this.div_ = document.createElement('DIV');\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.innerHTML = this.sums_.text;\n  }\n\n  var panes = this.getPanes();\n  panes.overlayMouseTarget.appendChild(this.div_);\n\n  var that = this;\n  google.maps.event.addDomListener(this.div_, 'click', function() {\n    that.triggerClusterClick();\n  });\n};\n\n\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\nClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= parseInt(this.width_ / 2, 10);\n  pos.y -= parseInt(this.height_ / 2, 10);\n  return pos;\n};\n\n\n/**\n * Draw the icon.\n * @ignore\n */\nClusterIcon.prototype.draw = function() {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + 'px';\n    this.div_.style.left = pos.x + 'px';\n    this.div_.style.zIndex = google.maps.Marker.MAX_ZINDEX + 1;\n  }\n};\n\n\n/**\n * Hide the icon.\n */\nClusterIcon.prototype.hide = function() {\n  if (this.div_) {\n    this.div_.style.display = 'none';\n  }\n  this.visible_ = false;\n};\n\n\n/**\n * Position and show the icon.\n */\nClusterIcon.prototype.show = function() {\n  if (this.div_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.style.display = '';\n  }\n  this.visible_ = true;\n};\n\n\n/**\n * Remove the icon from the map\n */\nClusterIcon.prototype.remove = function() {\n  this.setMap(null);\n};\n\n\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\nClusterIcon.prototype.onRemove = function() {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\nClusterIcon.prototype.setSums = function(sums) {\n  this.sums_ = sums;\n  this.text_ = sums.text;\n  this.index_ = sums.index;\n  if (this.div_) {\n    this.div_.innerHTML = sums.text;\n  }\n\n  this.useStyle();\n};\n\n\n/**\n * Sets the icon to the the styles.\n */\nClusterIcon.prototype.useStyle = function() {\n  var index = Math.max(0, this.sums_.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style['url'];\n  this.height_ = style['height'];\n  this.width_ = style['width'];\n  this.textColor_ = style['textColor'];\n  this.anchor_ = style['anchor'];\n  this.textSize_ = style['textSize'];\n  this.backgroundPosition_ = style['backgroundPosition'];\n};\n\n\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function(center) {\n  this.center_ = center;\n};\n\n\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\nClusterIcon.prototype.createCss = function(pos) {\n  var style = [];\n  style.push('background-image:url(' + this.url_ + ');');\n  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n  style.push('background-position:' + backgroundPosition + ';');\n\n  if (typeof this.anchor_ === 'object') {\n    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&\n        this.anchor_[0] < this.height_) {\n      style.push('height:' + (this.height_ - this.anchor_[0]) +\n          'px; padding-top:' + this.anchor_[0] + 'px;');\n    } else {\n      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +\n          'px;');\n    }\n    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&\n        this.anchor_[1] < this.width_) {\n      style.push('width:' + (this.width_ - this.anchor_[1]) +\n          'px; padding-left:' + this.anchor_[1] + 'px;');\n    } else {\n      style.push('width:' + this.width_ + 'px; text-align:center;');\n    }\n  } else {\n    style.push('height:' + this.height_ + 'px; line-height:' +\n        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\n  }\n\n  var txtColor = this.textColor_ ? this.textColor_ : 'black';\n  var txtSize = this.textSize_ ? this.textSize_ : 11;\n\n  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +\n      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +\n      txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\n  return style.join('');\n};\n\n\n// Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\nvar window = window || {};\nwindow['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] =\n    MarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] =\n    MarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] =\n    MarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] =\n    MarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] =\n    MarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] =\n    MarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] =\n    MarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] =\n    MarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] =\n    MarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] =\n    MarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] =\n    MarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] =\n    MarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] =\n    MarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] =\n    MarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\n\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\n\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;\n\nObject.keys = Object.keys || function(o) {\n    var result = [];\n    for(var name in o) {\n        if (o.hasOwnProperty(name))\n          result.push(name);\n    }\n    return result;\n};\n\nif (typeof module == 'object') {\n  module.exports = MarkerClusterer;\n}\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"App\"},[_c('b-button',{attrs:{\"squared\":\"\",\"variant\":\"outline-danger\"}},[_vm._v(\"Button\")])],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","// Your personal API key.\r\n// Get it here: https://console.cloud.google.com/google/maps-apis\r\nconst API_KEY = `AIzaSyDwyq_0oH_8Etl9KBwWNa9ZnXXCHxYrdnk`;\r\nconst CALLBACK_NAME = `gmapsCallback`;\r\n\r\nlet initialized = !!window.google;\r\nlet resolveInitPromise;\r\nlet rejectInitPromise;\r\n// This promise handles the initialization\r\n// status of the google maps script.\r\nconst initPromise = new Promise((resolve, reject) => {\r\n  resolveInitPromise = resolve;\r\n  rejectInitPromise = reject;\r\n});\r\n\r\nexport default function init() {\r\n  // If Google Maps already is initialized\r\n  // the `initPromise` should be resolved\r\n  // eventually.\r\n  if (initialized) return initPromise;\r\n\r\n  initialized = true;\r\n  // The callback function is called by\r\n  // the Google Maps script if it is\r\n  // successfully loaded.\r\n  window[CALLBACK_NAME] = () => resolveInitPromise(window.google);\r\n\r\n  // We inject a new script tag into\r\n  // the `<head>` of our HTML to load\r\n  // the Google Maps script.\r\n  const script = document.createElement(`script`);\r\n  script.async = true;\r\n  script.defer = true;\r\n  script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&callback=${CALLBACK_NAME}`;\r\n  script.onerror = rejectInitPromise;\r\n  document.querySelector(`head`).appendChild(script);\r\n\r\n  return initPromise;\r\n}\r\n","<template>\r\n    <div class=\"App\">\r\n        <b-button squared variant=\"outline-danger\">Button</b-button>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    import MarkerClusterer from '@google/markerclusterer';\r\n    import gmapsInit from '../utils/gmaps.js';\r\n    import gmaps from \"../utils/gmaps\";\r\n\r\n    export default {\r\n        props: {\r\n            locations: {\r\n                type: Array\r\n            }\r\n        },\r\n        data() {\r\n            return {\r\n                count: 0,\r\n            }\r\n        },\r\n        methods: {},\r\n        async mounted() {\r\n            try {\r\n                const google = await gmapsInit();\r\n                const geocoder = new google.maps.Geocoder();\r\n                const map = new google.maps.Map(this.$el);\r\n\r\n                this.locations.forEach(function (item) {\r\n                    delete item.pharmacyId;\r\n                });\r\n\r\n\r\n                geocoder.geocode({address: `Donetsk`}, (results, status) => {\r\n                    if (status !== `OK` || !results[0]) {\r\n                        throw new Error(status);\r\n                    }\r\n\r\n                    map.setCenter(this.locations[0].position);\r\n                    this.locations.length < 2 ? map.setZoom(15) : map.setZoom(12);\r\n\r\n                });\r\n\r\n                const markerClickHandler = (marker) => {\r\n\r\n                    let p = marker.getPosition();\r\n                    this.$emit(\"clickMarker\", p);\r\n                    map.setCenter(marker.getPosition());\r\n                };\r\n\r\n                const markers = this.locations\r\n                    .map((location) => {\r\n                        const marker = new google.maps.Marker({\r\n                            ...location,\r\n                            map,\r\n                            title: location.position.title\r\n                        });\r\n                        marker.addListener(`click`, () => markerClickHandler(marker));\r\n                        return marker;\r\n                    });\r\n\r\n                new MarkerClusterer(map, markers, {\r\n                    imagePath: `https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m`,\r\n                });\r\n\r\n            } catch (error) {\r\n                console.error(error);\r\n            }\r\n        },\r\n    };\r\n</script>\r\n\r\n<style scoped>\r\n    html,\r\n    body {\r\n        margin: 0;\r\n        padding: 0;\r\n    }\r\n\r\n    .App {\r\n        width: 100%;\r\n        height: 80vh;\r\n    }\r\n</style>\r\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Maps.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Maps.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./Maps.vue?vue&type=template&id=c8d5167e&scoped=true&\"\nimport script from \"./Maps.vue?vue&type=script&lang=js&\"\nexport * from \"./Maps.vue?vue&type=script&lang=js&\"\nimport style0 from \"./Maps.vue?vue&type=style&index=0&id=c8d5167e&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"c8d5167e\",\n  null\n  \n)\n\nexport default component.exports","'use strict';\nvar $ = require('../internals/export');\nvar $map = require('../internals/array-iteration').map;\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\nvar arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');\n// FF49- issue\nvar USES_TO_LENGTH = arrayMethodUsesToLength('map');\n\n// `Array.prototype.map` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n"],"sourceRoot":""}